<!DOCTYPE html><!--[if lte IE 8]>
<html lang="en" class="lte-ie8">
<![endif]-->
<!--[if gt IE 8]><!-->
<html lang="en">
<!--<![endif]--><head><meta charset="utf-8"><title>August 18, 2015</title><meta name="viewport" content="width=device-width, initial-scale=1.0"><link rel="stylesheet" href="/diary/styles/global.css"><link rel="stylesheet" href="/diary/styles/tomorrow.css"><link rel="stylesheet" href="/diary/styles/diary.css"><script>(function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
(i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
})(window,document,'script','//www.google-analytics.com/analytics.js','ga');

ga('create', 'UA-63818301-1', 'auto');
ga('send', 'pageview');</script></head><body><header class="header"><div class="index"><a href="/diary/">Index</a></div><h1>August 18, 2015</h1></header><div class="content"><div class="diary"><h2 id="c-">C++</h2>
<h3 id="-cppcon-2014-herb-sutter-back-to-the-basics-essentials-of-modern-c-style-https-www-youtube-com-watch-v-xnqtkd8ud64-"><a href="https://www.youtube.com/watch?v=xnqTKD8uD64">CppCon 2014: Herb Sutter &quot;Back to the Basics! Essentials of Modern C++ Style&quot;</a></h3>
<h4 id="focus-on-defaults">Focus on defaults</h4>
<ul>
<li>It&#39;s not dumbing the language down. It&#39;s about only do things otherwise when you have a good reason to do so. Don&#39;t optimize prematurely &amp; don&#39;t overthink.</li>
<li>Optimal by default v.s. good(but not optimal) performance by default</li>
<li>Clear code is more important than optimal code. You don&#39;t always need to open the hood.</li>
</ul>
<h4 id="range-for">Range For</h4>
<ul>
<li>If you need to traverse every element in the collection, prefer range-for with <code>auto &amp;</code> instead of iterators</li>
<li><code>for (e: c)</code> are coming!</li>
</ul>
<h4 id="when-to-use-smart-pointers">When to use smart pointers</h4>
<ul>
<li>Unique pointers are fairly cheap. Don&#39;t use owning *, <code>new</code> or <code>delete</code>. Use <code>make_unique</code> by default and <code>make_shared</code> if necessary, and you don&#39;t need to <code>delete</code> anymore.</li>
</ul>
<h4 id="when-not-to-use-smart-pointers">When not to use smart pointers</h4>
<ul>
<li><p>Non-owning references/pointers(lifetime controlled by callers) are still great!</p>
<pre><code class="lang-cpp"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">f</span><span class="hljs-params">(widget &amp;w)</span> </span>{
  use(w);
}

<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">g</span><span class="hljs-params">(widget *w)</span> </span>{
  <span class="hljs-keyword">if</span> (w) use(*w);
}
</code></pre>
<p>In modern C++, you pass them through <code>*smart_pointer</code> or <code>smart_pointer.get()</code>, but there&#39;s nothing wrong with the old pattern!</p>
</li>
<li>If you are not transferring ownership, just use the good old references/pointers for parameters, because <strong>the callee shouldn&#39;t care about if that thing is shared or unique anyway</strong>.</li>
<li><p>Anti-pattern: when you don&#39;t use the smart pointer properly:</p>
<pre><code class="lang-cpp"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">f</span><span class="hljs-params">(refcnt_ptr&lt;T&gt; &amp;w)</span> </span>{
  use(*w);  <span class="hljs-comment">// why on earth do you pass that reference when it will be counted?</span>
}
<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">f</span><span class="hljs-params">(refcnt_ptr&lt;T&gt; w)</span> </span>{
  use(*w);  <span class="hljs-comment">// pass-by-value?!</span>
  <span class="hljs-comment">// You'll be incrementing the reference with every call, doesn't it hurt?</span>
}
</code></pre>
</li>
<li><p>Anti-pattern: copy reference counted pointers in loops</p>
<pre><code class="lang-cpp">refcnt_ptr&lt;T&gt; w = ...;
<span class="hljs-keyword">for</span> (...) {
  <span class="hljs-keyword">auto</span> w2 = w;  <span class="hljs-comment">// WTF?!</span>
  use(w2);
}
</code></pre>
</li>
<li>FB RocksDB improve 4x by changing pass-by-value <code>shared_ptr</code> to raw pointers/references</li>
</ul>
<h4 id="ownership">Ownership</h4>
<ul>
<li>Reference counted smart pointers are about <strong>managing owned object&#39;s lifetime</strong>. Only copy/assign them when you need to manipulate the ownership!</li>
<li>People say smart pointers/vectors hurt performance because they are bitten by code that <strong>pass-by-value</strong> or <strong>copy/assign in loops</strong> with them, when they don&#39;t even intend to manipulate their ownerships.</li>
</ul>
<h4 id="how-to-use-unique_ptr-">How to use <code>unique_ptr</code></h4>
<ul>
<li>It&#39;s OK to <strong>return <code>unique_ptr</code></strong> in factories(remember to use <code>make_unique</code> for optimization)</li>
<li>It&#39;t OK to <strong>pass <code>unique_ptr</code> by value</strong> when you are about to consumes them.</li>
<li>If you <em>will</em> or <em>might</em> change where a <code>unique_ptr</code> points to, it&#39;s OK to <strong>pass it by reference</strong>.</li>
<li>It&#39;s usually <strong>not right</strong> to pass <code>const unique_ptr&lt;widget&gt; &amp;</code>. You should just pass a <code>const widget &amp;</code></li>
</ul>
<h4 id="how-to-use-shared_ptr-">How to use <code>shared_ptr</code></h4>
<ul>
<li>It&#39;t OK to <strong>eturn a <code>shared_ptr</code></strong> in factories(remember to use <code>make_shared</code> for optimization) when you know it will be shared.</li>
<li>If you want to share a <code>shared_ptr</code>(add one more reference count) to a function, you can <strong>pass it by value</strong>.</li>
<li>If you <em>will</em> or <em>might</em> change where a <code>unique_ptr</code> points to, it&#39;s OK to <strong>pass it by reference</strong>.</li>
<li>If you <em>might</em> share a <code>shared_ptr</code>, it&#39;s OK to pass <code>const shared_ptr&lt;widget&gt; &amp;</code></li>
</ul>
<h4 id="pitfalls">Pitfalls</h4>
<p>Don&#39;t dereference a non-local, possibly aliased reference-counted pointer, because it could be released elsewhere.</p>
<pre><code class="lang-cpp"><span class="hljs-built_in">shared_ptr</span>&lt;widget&gt; g_p; <span class="hljs-comment">// global or aliased local</span>

<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">f</span><span class="hljs-params">(widget &amp;w)</span> </span>{
  g();
  use(w);
}

<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">g</span><span class="hljs-params">()</span> </span>{
  g_p = ... <span class="hljs-comment">// reseat it</span>
}

<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">my_code</span><span class="hljs-params">()</span> </span>{
  f(*g_p); <span class="hljs-comment">// WARNING! g() might reseat `g_p`, releasing it, and then f() will dereference it with `use(w)`</span>
  <span class="hljs-comment">// or</span>
  g_p-&gt;foo();
}
</code></pre>
<p>How to do it properly? Pin it with an unaliased local copy so you can be sure it won&#39;t be released when dereferencing it. <strong>When you need to dereference a global smart pointer, copy it locally first</strong>.</p>
<pre><code class="lang-cpp"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">my_code</span><span class="hljs-params">()</span> </span>{
  <span class="hljs-keyword">auto</span> pin = g_p;  <span class="hljs-comment">// +1 ref count!</span>
  f(*pin);  <span class="hljs-comment">// now pin is local</span>
  <span class="hljs-comment">// or</span>
  pin-&gt;foo();
}
</code></pre>
<h4 id="principles">Principles</h4>
<ol>
<li>Never pass smart pointers(by value/reference) unless you want to manipulate its ownership</li>
<li>Use <code>unique_ptr</code> for ownership whenever possible, even when you don&#39;t know if it will be shared<ul>
<li>free, safe, declarative, no ref count headaches</li>
</ul>
</li>
<li>Else use <code>make_shared</code> up front when you know it will be shared. Don&#39;t dereference global <code>shared_ptr</code>, make a local copy before you do that.</li>
</ol>
<h4 id="don-t-be-scared-by-auto-">Don&#39;t be scared by <code>auto</code></h4>
<ul>
<li>A good IDE(even emacs) can help you see the actual type when you are coding, so don&#39;t be afraid of losing track of the types.</li>
<li><code>auto</code> makes you <strong>focus on interfaces</strong>, not implementations</li>
<li>Templates/temporaries already ignore actual types</li>
<li>With deduction, you always get the exact right type without accidentally changing modifiers/constness or getting <strong>implicit conversions</strong></li>
<li>Less typing LOL</li>
<li>No accidental narrowing on literals(e.g. <code>42.0f</code>, <code>42ul</code>)</li>
<li>The signatures will be on the right. Most of the times <code>auto</code> force you to put any possible conversions explicitly <strong>on the right hand side</strong>. If you put it on the left hand side(usually it&#39;s what you do when you don&#39;t use <code>auto</code>), people will keep NOT seeing it.</li>
<li><code>=</code> doesn&#39;t always mean copy/assignment in C++. That&#39;s a quirk in the standard -- it could mean initialization.</li>
<li>If you do <code>auto x = something</code>, something will be moved instead of copied. But if it&#39;s not movable, there could be an error(and remember, containers are expensive to move).</li>
</ul>
<p>So, no implicit conversions/temporaries, no narrowing, no uninitialized variables!</p>
<h3 id="rvo-and-move-semantics">RVO and Move semantics</h3>
<h4 id="in-c-98">In C++ 98</h4>
<ul>
<li>Cheap costs(e.g. a few <code>int</code>s) to copy: return-by-value and pass-by-value</li>
<li>Moderate costs(e.g. ~1KB contiguous)/unknown costs to copy: rely on RVO, pass by const references</li>
<li>Expensive to copy(e.g. vectors, <code>BigPOD[]</code>): use references all the way through</li>
</ul>
<h4 id="modern-c-">Modern C++</h4>
<ul>
<li>For cheap costs/impossible to copy(e.g. <code>unique_ptr</code>, return-by-value and pass-by-value(will trigger move semantics if necessary)</li>
<li>For moderate costs/cheap to move/unknown costs(e.g. <code>vector</code>, <code>array&lt;vector&gt;</code>, <code>BigPOD</code>), rely on RVO, pass by const references</li>
<li>Expensive to move(e.g. <code>BigPOD[]</code>, <code>array&lt;BigPOD&gt;</code>), use references all the way through</li>
</ul>
<p>So in more cases you just need RVO and const references.</p>
<ul>
<li>If you want to optimize for rvalues, add an overload for <code>&amp;&amp;</code></li>
<li>For constructors, pass-by-value and then move might still be a good option, but usually just stick to <code>const &amp;</code></li>
<li><code>T &amp;&amp;</code> is <strong>forwarding reference</strong>(because it doesn&#39;t care about T is <code>const</code> or whatnot)</li>
</ul>
<h3 id="multiple-return-values">Multiple return values</h3>
<p>C++ 98: <code>pair</code>s</p>
<pre><code class="lang-cpp">pair&lt;<span class="hljs-built_in">set</span>&lt;<span class="hljs-built_in">string</span>&gt;::iterator, <span class="hljs-keyword">bool</span>&gt; result = func();
<span class="hljs-keyword">if</span> (result.second) use(result.first);
</code></pre>
<p>C++ 11 with backward compatibility</p>
<pre><code class="lang-cpp"><span class="hljs-keyword">auto</span> result = func();
<span class="hljs-keyword">if</span> (result.second) use(result.first);
</code></pre>
<p>C++ 11 new syntax</p>
<pre><code class="lang-cpp"><span class="hljs-comment">// declare iterator and success earlier...don't forget to initialize them!</span>
tie(iterator, success) = func();
<span class="hljs-keyword">if</span> (success) use(iterator)
</code></pre>
</div></div><footer class="footer"><address class="author">Copyright &copy;<a rel="author" href="https://github.com/joyeecheung" class="author-name">Joyee Cheung</a>-<a href="https://github.com/joyeecheung/my-tech-diary" class="source-repo">Source</a></address><p>Generated by<a href="https://github.com/joyeecheung/diary" class="site-repo">Joyee Cheung&#39;s diary generator</a></p></footer></body></html>