<!DOCTYPE html><!--[if lte IE 8]>
<html lang="en" class="lte-ie8">
<![endif]-->
<!--[if gt IE 8]><!-->
<html lang="en">
<!--<![endif]--><head><meta charset="utf-8"><title>August 29, 2015</title><meta name="viewport" content="width=device-width, initial-scale=1.0"><link rel="stylesheet" href="/diary/styles/global.css"><link rel="stylesheet" href="/diary/styles/tomorrow.css"><link rel="stylesheet" href="/diary/styles/diary.css"><script>(function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
(i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
})(window,document,'script','//www.google-analytics.com/analytics.js','ga');

ga('create', 'UA-63818301-1', 'auto');
ga('send', 'pageview');</script></head><body><header class="header"><div class="index"><a href="/diary/">Index</a></div><h1>August 29, 2015</h1></header><div class="content"><div class="diary"><h2 id="js-engine">JS Engine</h2>
<h3 id="-a-tour-of-v8-full-compiler-http-jayconrod-com-posts-51-a-tour-of-v8-full-compiler-"><a href="http://jayconrod.com/posts/51/a-tour-of-v8-full-compiler">A tour of V8: full compiler</a></h3>
<h4 id="high-level-architecture">High level architecture</h4>
<ul>
<li>V8 has a full compiler and an optimizing compiler. There&#39;s no interpreter, everything will be compiled to machine code.</li>
<li>Full compiler compiles JS code without any transformation/optimization. It&#39;s job is to make the code available to run as quickly as possible, so the web pages can load quickly.</li>
<li>The optimizing compiler(Crankshaft) will optimize hot functions selected by the profiler</li>
<li>Additional notes(not in this article)<ul>
<li>V8 now has multiple threads for these. The main thread does compilation and execution, and there is another one just for compilation. Profiler is on another, and there are a few more for GC.</li>
<li>The main thread will stop execution when doing Crankshaft optimizations</li>
<li>Optimization is done on the Hydrogen(a static-single assignment representation of the control flow graph)</li>
<li>Hydrogen will be translated into the low-level Lithium(platform-dependent), this is where the register allocation is done</li>
<li>Lithium will then be translated into machine code</li>
</ul>
</li>
</ul>
<h4 id="why-no-bytecode-">Why no bytecode?</h4>
<ul>
<li>Native compilation is not that more expensive than bytecode compilation.</li>
<li>You still need to go through parsing, scope analysis(for local variables, content variables(closures), global properties).</li>
<li>The only difference is that during code generation, you generate machine code(platform-specific) instead of bytecode(platform-independent)</li>
<li>In V8 we just skip the translation from bytecode to machine code. This simplifies transitions between unoptimized and optimized code!(easier for OSR)</li>
</ul>
<blockquote>
<p>In general, bytecode is useful in situations where you can do some of the compiler&#39;s work <strong>ahead of time</strong></p>
</blockquote>
<h4 id="inline-caches-accelerating-unoptimized-code">Inline caches: accelerating unoptimized code</h4>
<ul>
<li>Operations in ES are too complicated(due to type coersion, prototypes, etc.)</li>
<li>IC: a function with multiple possible implementations(usually generated on the fly)</li>
<li>The full compiler uses ICs to implement load/store/call/binary op/unary op/comparison/implicit <code>ToBoolean</code></li>
<li>Stub: implementation of an IC<ul>
<li>Like functions, but don&#39;t necessarily set up a stack frame/follow the function call convention</li>
<li>Usually generated on the fly</li>
<li>Can be cached and reused by ICs</li>
<li>Contains optimized code for operations that some IC has encountered before(so it&#39;s a <em>cache</em>)</li>
<li>If the type misses, the C++ runtime code will be called instead. Then it will generate a new stub to replace it.</li>
</ul>
</li>
<li>IC starts in the <em>uninitialized</em> state, where the stub doesn&#39;t handle any cases. When it&#39;s called it will generate a new stub that handle the case and replace the old stub with it(this is how hidden classes are created too(in-object load stubs!)).<ul>
<li>Uninitialized -&gt;(first call/cache miss) -&gt; monomorphic -&gt; (cache miss) -&gt; megamorphic</li>
</ul>
</li>
</ul>
</div></div><footer class="footer"><address class="author">Copyright &copy;<a rel="author" href="https://github.com/joyeecheung" class="author-name">Joyee Cheung</a>-<a href="https://github.com/joyeecheung/my-tech-diary" class="source-repo">Source</a></address><p>Generated by<a href="https://github.com/joyeecheung/diary" class="site-repo">Joyee Cheung&#39;s diary generator</a></p></footer></body></html>